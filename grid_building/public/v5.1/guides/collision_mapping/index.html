<!doctype html><html lang=en-us><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Collision Mapping | GridBuilding Plugin</title>
<meta name=description content="Collision Mapping documentation for the Grid Building system"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=/css/custom.css><meta name=generator content="Hugo 0.146.5"></head><body><div class=gb-layout><header class=gb-header><a href=/ class=gb-brand><i class="fas fa-cubes" style=color:var(--gb-primary)></i>
<span>GridBuilding Plugin</span></a><div class=gb-search><i class="fas fa-search"></i>
<input type=text placeholder="Search documentation..." aria-label=Search></div><nav class=gb-nav><a href=/ class=gb-nav-link>Home
</a><a href=/v6.0/overview/ class=gb-nav-link>Documentation
</a><a href=/v5.1/overview/ class=gb-nav-link>Grid Building Plugin Overview
</a><a href=/v6.0/api/ class=gb-nav-link>API Reference
</a><a href=/v5.1/guides/ class=gb-nav-link>Getting Started Guides
</a><a href=/v6.0/examples/ class=gb-nav-link>Examples
</a><a href=/v5.1/examples/ class=gb-nav-link>Code Examples
</a><a href=/community/ class=gb-nav-link>Community
</a><a href=/v5.1/architecture-diagrams/ class=gb-nav-link>Architecture Diagrams</a></nav></header><aside class=gb-sidebar><nav class=gb-sidebar-nav><div class=gb-sidebar-section><div class=gb-sidebar-title>V6.0s</div><a href=/v6.0/guides/6-0-readiness-status/ class=gb-sidebar-link>GridBuilding 6.0 Readiness Status
</a><a href=/v6.0/guides/getting_started/ class=gb-sidebar-link>Getting Started with GridBuilding
</a><a href=/v6.0/guides/mode-architecture/ class=gb-sidebar-link>GridBuilding 6.0 Mode Architecture
</a><a href=/v6.0/guides/gdscript-to-csharp-mapping/ class=gb-sidebar-link>GDScript to C# Migration Guide
</a><a href=/v6.0/guides/csharp_state_integration/ class=gb-sidebar-link>C# State Integration with Godot Frontend
</a><a href=/v6.0/guides/troubleshooting/ class=gb-sidebar-link>Troubleshooting Guide
</a><a href=/v6.0/examples/godot_integration_example/ class=gb-sidebar-link>Godot Integration Example
</a><a href=/gridbuilding/v6.0-public/guides/dependency-resolution/ class=gb-sidebar-link>Dependency Resolution in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/userid-quickstart/ class=gb-sidebar-link>Quick Start: Game-Owned UserId & Multi-Owner Orchestrators
</a><a href=/gridbuilding/v6.0-public/guides/building-system-architecture/ class=gb-sidebar-link>BuildingSystem Architecture (Legacy Session Orchestrator)
</a><a href=/gridbuilding/v6.0-public/guides/multi-owner-orchestration-priorities/ class=gb-sidebar-link>Multi-Owner Orchestration Priorities (v6.0)
</a><a href=/gridbuilding/v6.0/guides/placement-system-architecture/ class=gb-sidebar-link>Placement System and Architecture in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/manipulation-system-architecture/ class=gb-sidebar-link>ManipulationSystemNode Architecture (Session Orchestrator)
</a><a href=/v6.0/guides/service_based_architecture/ class=gb-sidebar-link>Service-Based Architecture
</a><a href=/gridbuilding/v6-0/api/ class=gb-sidebar-link>GridBuilding API Reference</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.1.0</div><a href=/v5.1/overview/ class=gb-sidebar-link>Grid Building Plugin Overview
</a><a href=/v5.1/guides/ class=gb-sidebar-link>Getting Started Guides
</a><a href=/v5.1/api/ class=gb-sidebar-link>C# API Reference
</a><a href=/v5.1/examples/ class=gb-sidebar-link>Code Examples
</a><a href=/v5.1/architecture-diagrams/ class=gb-sidebar-link>Architecture Diagrams
</a><a href=/v5.1/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.1/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.1/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.1/validation/ class=gb-sidebar-link>Validation Tools</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.0.0</div><a href=/v5.0/api/ class=gb-sidebar-link>GDScript API Reference
</a><a href=/v5.0/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.0/overview/ class=gb-sidebar-link>Grid Building Plugin v5.0.0
</a><a href=/v5.0/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.0/guides/ class=gb-sidebar-link>Plugin Overview
</a><a href=/v5.0/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.0/validation/ class=gb-sidebar-link>Validation Tools</a></div></nav></aside><main class=gb-main><div class=gb-content><h1>Collision Mapping</h1><hr><p>How the plugin turns 2D collision into grid tiles for placement rules and indicators.
<a href=../api/CollisionMapper/>CollisionMapper</a> is the central orchestrator that extracts collision geometry from objects and produces tile position → rule / object maps.
Introduced in v5.0.0 as a refactoring and enhancement of previous collision handling logic.</p><p><strong>Grid Building 5.0.0 features thoroughly tested and validated collision detection</strong> with:</p><ul><li><strong>Multi-shape collision support</strong> for complex building footprints</li><li><strong>Precise edge case handling</strong> for overlapping geometries</li><li><strong>Optimized physics queries</strong> with intelligent caching</li><li><strong>Validated collision mathematics</strong> backed by comprehensive automated tests</li></ul><h2 id=purpose>Purpose</h2><p>When a player previews or places a building/object, the system needs to know which grid tiles are &ldquo;touched&rdquo; by that object&rsquo;s collision so that:</p><p>The Collision Mapping subsystem standardizes this translation with consistent geometric rules and thresholds. In practice, the subsystem is most often invoked by indicator code (for example <a href=../api/IndicatorManager/>IndicatorManager</a> / <a href=../api/RuleCheckIndicator/>RuleCheckIndicator</a>) during preview and placement: the indicator layer asks the mapper to map the preview instance&rsquo;s collision against the active <code>TileMapLayer</code> and then creates per-tile indicators for every tile that passes the mapping and significance filters.</p><h2 id=key-components>Key Components</h2><table><thead><tr><th>Component</th><th>Responsibility</th></tr></thead><tbody><tr><td><a href=../api/CollisionMapper/>CollisionMapper</a></td><td>Orchestrates extraction of collision geometry from objects and produces tile position → rule / object maps.</td></tr><tr><td><a href=../api/CollisionMapper/>CollisionMapper</a> caching</td><td>The mapper implements per-frame geometry caching (polygon, bounds, tile results) to reduce repeated work during previews.</td></tr><tr><td><a href=../api/CollisionTestSetup2D/>CollisionTestSetup2D</a></td><td>Lightweight context wrapper storing an object&rsquo;s transform, origin offset, and cached geometry meta used in mapping.</td></tr><tr><td><a href=../api/RuleCheckIndicator/>RuleCheckIndicator</a></td><td>Visual probe shape whose bounds define the sampling region; per-frame it revalidates placement using mapped collision tiles.</td></tr><tr><td><a href=../api/GBGeometryMath/>GBGeometryMath</a></td><td>Static geometry helpers: shape → polygon conversion (shape→polygon conversion continues to use GBGeometryMath).</td></tr><tr><td><a href=../api/CollisionGeometryUtils/>CollisionGeometryUtils</a></td><td>Stateless helpers that drive the unified polygon→tile path (delegates to CollisionGeometryCalculator). Contains conservative test defaults (edge epsilon, min area fraction) used across tests and the mapper.</td></tr><tr><td><a href=../api/CollisionGeometryCalculator/>CollisionGeometryCalculator</a></td><td>Pure geometry calculator: precise polygon/tile overlap, clipping and area calculations used by CollisionGeometryUtils and tests.</td></tr><tr><td><a href=../api/CollisionProcessor/>CollisionProcessor</a></td><td>Runtime processor that unifies polygon and shape paths, returns relative offsets for indicators and manages internal caching for performance optimization.</td></tr><tr><td><a href=../api/TileCheckRule/>TileCheckRule</a></td><td>Rule data object listing which collision layers (mask) it applies to and additional semantic constraints.</td></tr><tr><td><a href=../api/GridTargetingState/>GridTargetingState</a></td><td>Aggregates targeting context: maps, positioner, currently inspected TileMap layer, etc.</td></tr></tbody></table><h2 id=at-a-glance>At a glance</h2><pre><code>	- The mapping pipeline now uses a unified geometry path: [CollisionGeometryUtils](../api/CollisionGeometryUtils/) (test-friendly helpers) delegates to the precise [CollisionGeometryCalculator](../api/CollisionGeometryCalculator/) for polygon→tile overlap calculations. Defaults used in tests are: edge epsilon = 0.01 and min area fraction = 0.05 (5%).
	- Shapes: shape→polygon conversion is still performed via `GBGeometryMath.convert_shape_to_polygon`, then fed through the unified polygon path. Shape processing uses a baseline `shape_epsilon` ≈ 0.035 in the shape path.
		- Round primitives (circle / capsule) use a slightly lower per-tile threshold (~0.025) and additional corner pruning / mirroring logic to avoid spurious corner tiles.
	- Polygons: the mapper-level polygon sliver suppression constant remains `MIN_POLY_TILE_OVERLAP_RATIO = 0.12` (12%) and is defined on the runtime mapper where rule-level aggregation occurs.
</code></pre><p>Currently supported primitive shapes (converted to polygons):</p><ul><li><code>RectangleShape2D</code> → 4-point polygon</li><li><code>CircleShape2D</code> → N-gon approximation (default 16 segments)</li><li><code>CapsuleShape2D</code> / Capsule approximation → approximated polygon (often replaced by explicit <code>CollisionPolygon2D</code> in assets)</li></ul><h2 id=shape--polygon-conversion>Shape → Polygon Conversion</h2><p>All collision evaluation reduces to polygon vs tile area overlap. Each source shape is converted into a local-space polygon and then transformed into world space using the owning node&rsquo;s global transform plus any indicator offset. For complex objects with multiple shapes, polygons are processed independently and merged into a tile coverage map.</p><p>Advantages:</p><ul><li>Unified overlap test implementation (single polygon→tile path simplifies verification and testing)</li><li>Enables accurate partial-tile filtering via area-based thresholds (prevents hairline contacts from triggering tiles)</li><li>Supports arbitrary future shapes by adding a single shape→polygon converter; all downstream code re-uses the unified overlap routine</li></ul><h2 id=how-it-works>How it works</h2><p>The grid uses uniform tiles (commonly 16×16).</p><ol><li>Collect sources matching the rule’s layer mask.</li><li>Convert each shape to a polygon in world space (polygons are already polygons).</li><li>Iterate candidate tiles from the polygon’s bounds and test overlap. In the current implementation this iteration and overlap testing is performed by <code>CollisionGeometryCalculator.calculate_tile_overlap()</code> (via <code>CollisionGeometryUtils.compute_polygon_tile_offsets()</code>), ensuring polygon and shape code paths produce identical tile sets.</li><li>Apply significance filters (shape_epsilon ≈ 0.035 for shapes; 0.025 for round shapes; 12% for polygons) and de‑duplicate tiles.</li></ol><h3 id=significance-filters>Significance filters</h3><p>These thresholds prevent hairline contacts and micro‑slivers from creating indicators or failing rules. Polygons use clipped area so we can discard tiles with negligible true coverage. Round-shape corner tiles are subject to stricter corner thresholds (commonly ~20% of tile area) during corner pruning to eliminate spurious single‑pixel touches on curved geometry.</p><h3 id=multiple-shapes--aggregation>Multiple Shapes & Aggregation</h3><p>If multiple shapes overlap the same tile, that tile is inserted only once; the system aggregates contributing objects or rules in a list attached to the tile coordinate key.</p><h2 id=collision-layers--rule-filtering>Collision Layers & Rule Filtering</h2><p>Each <a href=../api/TileCheckRule/>TileCheckRule</a> declares an <code>apply_to_objects_mask</code>. During mapping, collision objects are filtered by their collision layer bits. A tile is considered relevant for a rule only if at least one contributing object has a matching layer bit set. This ensures rules don&rsquo;t falsely trigger on unrelated decorative collisions.</p><p>Examples:</p><h2 id=indicator-integration>Indicator Integration</h2><p><a href=../api/RuleCheckIndicator/>RuleCheckIndicator</a> performs per-frame validation:</p><ol><li>Indicator requests collision mapping within its shape bounds</li><li>Placement rules are evaluated against the mapped tile set</li><li>Visual state (valid/invalid color) updates immediately when geometry changes (e.g. moving over edge cases)</li></ol><p>The indicator shape itself does not contribute to collision mapping—it&rsquo;s a sampling window that caps unnecessary tile iteration.</p><h2 id=indicator-positioning>Indicator Positioning</h2><p>After collision mapping determines which tiles are occupied by a test object, the system needs to position visual indicators to show validation results. The positioning follows a specific transformation from absolute collision coordinates to relative indicator placement.</p><h3 id=collision-to-indicator-positioning-flow>Collision-to-Indicator Positioning Flow</h3><ol><li><p><strong>Collision Detection</strong>: The collision mapping system identifies absolute tile positions where the test object&rsquo;s collision shapes (CollisionShape2D, CollisionPolygon2D) would intersect with the tilemap.</p></li><li><p><strong>Position Normalization</strong>: Each collision tile position is normalized into a consistent relative offset pattern using modulo arithmetic:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#ff7b72>var</span> offset_x <span style=color:#ff7b72;font-weight:700>=</span> (position<span style=color:#ff7b72;font-weight:700>.</span>x <span style=color:#ff7b72;font-weight:700>%</span> <span style=color:#a5d6ff>7</span>) <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>3</span>  <span style=color:#8b949e;font-style:italic># Range: -3 to +3 tiles</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> offset_y <span style=color:#ff7b72;font-weight:700>=</span> (position<span style=color:#ff7b72;font-weight:700>.</span>y <span style=color:#ff7b72;font-weight:700>%</span> <span style=color:#a5d6ff>7</span>) <span style=color:#ff7b72;font-weight:700>-</span> <span style=color:#a5d6ff>3</span>  <span style=color:#8b949e;font-style:italic># Range: -3 to +3 tiles</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Relative Positioning</strong>: Indicators are positioned relative to the test object&rsquo;s current location, not at the absolute collision coordinates. This ensures indicators maintain consistent spatial relationships when the test object moves.</p></li><li><p><strong>World Coordinate Translation</strong>: The normalized offsets are applied to the test object&rsquo;s tile position and converted back to world coordinates for final indicator placement.</p></li></ol><h3 id=key-positioning-behaviors>Key Positioning Behaviors</h3><ul><li>Movement Following: When the test object moves, indicators automatically follow while preserving their relative layout pattern.</li><li>Consistent Patterns: The modulo-based normalization produces deterministic indicator layouts for the same collision patterns.</li><li>Tile-Based Offsets: Indicators are placed using whole-tile offsets relative to the test object&rsquo;s center (no sub-tile offsets).</li><li>Shape-Aware Placement: Different collision silhouettes (rectangles, circles, polygons) produce different mapped tile sets and therefore different indicator arrangements.</li></ul><h3 id=initial-collision-testing>Initial Collision Testing</h3><p>The positioning system begins by mapping collision geometry into candidate tiles and then deciding which tiles should receive indicators:</p><ul><li>CollisionShape2D Sources: Rectangle, circle, and capsule shapes are converted to polygons (via <code>GBGeometryMath.convert_shape_to_polygon</code>) and tested for tile overlap.</li><li>CollisionPolygon2D Sources: Polygons are tested directly using polygon→tile overlap and clipping.</li><li>Layer Mask Filtering: Only collision objects matching the rule&rsquo;s <code>apply_to_objects_mask</code> contribute to the mapped tile set used for indicator generation.</li><li>Significance Thresholds: Minimum overlap requirements and pruning heuristics are applied before indicators are created to avoid noise from negligible contacts.
The positioning system begins with comprehensive collision testing against the test object&rsquo;s shapes:</li></ul><p>This approach transforms raw collision detection results into meaningful spatial feedback, showing players exactly where placement constraints apply relative to their intended build location.</p><h2 id=precision-vs-performance>Precision vs Performance</h2><p>Optimizing collision mapping is about choosing sensible defaults that preserve placement accuracy while avoiding per-frame expensive computation during previews. The subsystem uses a few small techniques to balance precision and runtime cost:</p><p>Optimizations:</p><ul><li>Bounds pruning: most geometry is quickly rejected by testing tile-bounds overlap before performing precise polygon clipping.</li><li>Per-frame caching: <a href=../api/CollisionMapper/>CollisionMapper</a> and <a href=../api/CollisionProcessor/>CollisionProcessor</a> implement internal geometry caching to reuse intermediate polygons and tile masks during continuous previews.</li><li>Unified polygon path: converting shapes to polygons and running a single polygon→tile routine reduces duplicated code and allows a single, optimized hot path (<a href=../api/CollisionGeometryCalculator/>CollisionGeometryCalculator</a>).</li><li>Sliver suppression & significance filters: area-based thresholds eliminate tiny overlaps that would otherwise create noisy indicators or false rule failures.</li></ul><h3 id=normalization-helpers>Normalization helpers</h3><p>The repo exposes small helpers and filters to make indicator placement deterministic and easier to reason about:</p><ul><li><a href=../api/GBCollisionTileFilter/>GBCollisionTileFilter</a> — utilities for normalizing tile spans, enforcing odd-span centering, and mirroring/pruning corner tiles for round primitives. See the API page: <a href=../api/GBCollisionTileFilter/>GBCollisionTileFilter</a>.</li><li>Tile offset normalization — the indicator positioning flow uses modulo-based normalization (documented above) to convert absolute collision tile coordinates into stable relative offsets.</li></ul><p>Performance Notes:</p><ul><li>Caching scope: caches are intentionally per-preview (per-indicator) and invalidated when transforms or the target tilemap change; internal polygon caches are maintained to avoid expensive rebuilds across many previews.</li><li>Hot-path cost: the most expensive work is polygon clipping and exact area calculation in <a href=../api/CollisionGeometryCalculator/>CollisionGeometryCalculator</a>. Keep complex polygon vertex counts reasonable in authored assets when possible.</li><li>Tuning knobs: use the mapper and geometry utils constants (edge epsilon, min area fraction, <code>MIN_POLY_TILE_OVERLAP_RATIO</code>) to relax or tighten sensitivity — configuration is documented on the respective API pages (see links).</li></ul><h2 id=cross-links>Cross-links</h2><ul><li><a href=../api/CollisionMapper/>CollisionMapper</a></li><li><a href=../api/CollisionProcessor/>CollisionProcessor</a></li><li><a href=../api/CollisionGeometryUtils/>CollisionGeometryUtils</a></li><li><a href=../api/CollisionGeometryCalculator/>CollisionGeometryCalculator</a></li><li><a href=../api/GBCollisionTileFilter/>GBCollisionTileFilter</a></li></ul><hr><p>Support / Purchase Hub: <strong><a href=https://linktr.ee/gridbuilder>Linktree – All Grid Builder Links</a></strong></p><h2 id=examples>Examples</h2><h3 id=small-1515-rectangle-on-1616-grid>Small 15×15 rectangle on 16×16 grid</h3><ul><li>Bounds cover approximately one tile</li><li>Overlap area = 225 px² (> 5% threshold) so the tile is mapped</li><li>Mapped tiles: 1</li></ul><h3 id=thin-edge-polygon-0101-touching-a-tile-corner>Thin edge polygon (0.1×0.1) touching a tile corner</h3><ul><li>Very small area compared to tile size (e.g. 0.01 px²) — below the min-area threshold</li><li>Filtered out and produces 0 mapped tiles</li></ul><h3 id=complex-building-with-multiple-collisionshapes>Complex building with multiple CollisionShapes</h3><ul><li>Each shape is converted independently to polygons and mapped</li><li>Tiles are aggregated and de-duplicated; if multiple shapes contribute the same tile, the tile stores references to all contributors (useful for rule attribution)</li></ul><h2 id=tests>Tests</h2><p>Automated coverage includes layer filtering, rectangle + polygon overlap (multi‑tile), significance filters, trapezoid heuristics, and concave handling.</p><p>Targeted regressions:</p><h2 id=authoring-tips>Authoring tips</h2><h2 id=extensibility>Extensibility</h2><p>To add a new shape type:</p><ol><li>Implement shape → polygon conversion in <a href=../api/GBGeometryMath/>GBGeometryMath</a></li><li>Add test ensuring correct vertex count and bounds</li><li>(If needed) Expose editor tooling to simplify generating the polygon</li></ol><p>To adjust sensitivity:</p><h2 id=known-limitations--future-work>Known limitations & future work</h2><table><thead><tr><th>Area</th><th>Current State</th><th>Potential Enhancement</th></tr></thead><tbody><tr><td>Concave polygons</td><td>Supported (processed as provided) but no auto-decomposition</td><td>Decompose to convex parts for potential faster intersection</td></tr><tr><td>Rotated tileset grids</td><td>Assumes axis-aligned square tiles</td><td>Add support for isometric / staggered grids</td></tr><tr><td>Large dynamic objects</td><td>Per-frame full remap</td><td>Add incremental dirty-region updates</td></tr><tr><td>Epsilon globality</td><td>Single threshold shared across rules</td><td>Per-rule or per-layer override</td></tr></tbody></table><h2 id=parenting--movement>Parenting & movement</h2><ol><li>Shapes: offsets pivot around the owner’s tile (stable if only the positioner moves).</li><li>Polygons: offsets pivot around the positioner’s tile.</li><li>Offsets = <code>tile_pos - center_tile</code>.</li></ol><h2 id=summary>Summary</h2><p>Collision mapping converts all relevant 2D collision shapes into polygons, determines significantly overlapped tiles using a fractional area threshold, filters them by rule-relevant collision layers, and feeds this tile set into placement validation and visual feedback. The design balances accuracy (tight polygon outlines) with performance (bounds pruning + epsilon) to deliver responsive, reliable placement previews.</p><h2 id=change-log-focused-excerpts>Change log (focused excerpts)</h2><table><thead><tr><th>Date</th><th>Change</th><th>Rationale</th><th>Impact</th></tr></thead><tbody><tr><td>2025-09-16</td><td>Added comprehensive &ldquo;Indicator Positioning&rdquo; section documenting collision-to-indicator transformation</td><td>Document how collision detection results are transformed into relative indicator positioning</td><td>Improves developer understanding of positioning system architecture</td></tr><tr><td>2025-08-18</td><td>Reverted experimental bounds-center polygon pivot to positioner-centered model</td><td>Preserve established test & gameplay frame of reference</td><td>Keeps existing offset expectations; removes need for test rewrites</td></tr><tr><td>2025-08-18</td><td>Introduced generic rectangle/circle tile normalization utilities (<a href=../api/GBCollisionTileFilter/>GBCollisionTileFilter</a>)</td><td>Remove magic size branches (32x48, radius 24)</td><td>More maintainable, symmetrical coverage without hardcoded cases</td></tr><tr><td>2025-08-18</td><td>Restored trapezoid expected coverage (13 tiles) after mapper corrections</td><td>Validate intended geometry</td><td>Prevents silent coverage shrink regression</td></tr><tr><td>2025-08-21</td><td>Added polygon min‑area filter (12%) and rectangle center‑anchored odd‑span normalization</td><td>Eliminate slivers; ensure full used‑space (e.g., Smithy bottom‑middle)</td><td>Stable, predictable coverage; parity with tests</td></tr><tr><td>2025-08-21</td><td>Changed CollisionObject2D shape pivoting: shape offsets pivot around the <em>owner&rsquo;s</em> tile (owner-centered) while polygon sources remain positioner-centered; allowed Area2D rectangle sources to contribute</td><td>Decouple shape offsets from the targeting positioner and avoid surprising offset changes when moving only the positioner</td><td>More intuitive behavior; requires no test rebase for most cases</td></tr><tr><td>2025-08-21</td><td>Per-shape tuning for round primitives: lower area threshold and corner pruning, plus symmetric mirroring enforcement</td><td>Remove spurious corner tiles for circles/capsules and ensure left/right symmetry</td><td>Improved UX for round shapes and consistent indicator geometry</td></tr></tbody></table><hr><p>Last updated: 2025-09-16</p></div></main><aside class=gb-toc><div class=gb-toc-title>On this page</div><nav id=TableOfContents><ul><li><a href=#purpose>Purpose</a></li><li><a href=#key-components>Key Components</a></li><li><a href=#at-a-glance>At a glance</a></li><li><a href=#shape--polygon-conversion>Shape → Polygon Conversion</a></li><li><a href=#how-it-works>How it works</a><ul><li><a href=#significance-filters>Significance filters</a></li><li><a href=#multiple-shapes--aggregation>Multiple Shapes & Aggregation</a></li></ul></li><li><a href=#collision-layers--rule-filtering>Collision Layers & Rule Filtering</a></li><li><a href=#indicator-integration>Indicator Integration</a></li><li><a href=#indicator-positioning>Indicator Positioning</a><ul><li><a href=#collision-to-indicator-positioning-flow>Collision-to-Indicator Positioning Flow</a></li><li><a href=#key-positioning-behaviors>Key Positioning Behaviors</a></li><li><a href=#initial-collision-testing>Initial Collision Testing</a></li></ul></li><li><a href=#precision-vs-performance>Precision vs Performance</a><ul><li><a href=#normalization-helpers>Normalization helpers</a></li></ul></li><li><a href=#cross-links>Cross-links</a></li><li><a href=#examples>Examples</a><ul><li><a href=#small-1515-rectangle-on-1616-grid>Small 15×15 rectangle on 16×16 grid</a></li><li><a href=#thin-edge-polygon-0101-touching-a-tile-corner>Thin edge polygon (0.1×0.1) touching a tile corner</a></li><li><a href=#complex-building-with-multiple-collisionshapes>Complex building with multiple CollisionShapes</a></li></ul></li><li><a href=#tests>Tests</a></li><li><a href=#authoring-tips>Authoring tips</a></li><li><a href=#extensibility>Extensibility</a></li><li><a href=#known-limitations--future-work>Known limitations & future work</a></li><li><a href=#parenting--movement>Parenting & movement</a></li><li><a href=#summary>Summary</a></li><li><a href=#change-log-focused-excerpts>Change log (focused excerpts)</a></li></ul></nav></aside><footer class=gb-footer><p>&copy; 2025 Chris Tutorials. All rights reserved.</p><p>Built with <a href=https://gohugo.io/ target=_blank>Hugo</a> and
<a href=https://godotengine.org/ target=_blank>Godot</a>.</p></footer></div></body></html>