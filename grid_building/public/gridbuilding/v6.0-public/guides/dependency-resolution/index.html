<!doctype html><html lang=en-us><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Dependency Resolution in GridBuilding v6.0 (Godot) | GridBuilding Plugin</title>
<meta name=description content="How GridBuilding systems and services resolve their dependencies using ServiceCompositionRoot, ServiceRegistry, and CompositionContainer."><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=/css/custom.css><meta name=generator content="Hugo 0.146.5"></head><body><div class=gb-layout><header class=gb-header><a href=/ class=gb-brand><i class="fas fa-cubes" style=color:var(--gb-primary)></i>
<span>GridBuilding Plugin</span></a><div class=gb-search><i class="fas fa-search"></i>
<input type=text placeholder="Search documentation..." aria-label=Search></div><nav class=gb-nav><a href=/ class=gb-nav-link>Home
</a><a href=/v6.0/overview/ class=gb-nav-link>Documentation
</a><a href=/v5.1/overview/ class=gb-nav-link>Grid Building Plugin Overview
</a><a href=/v6.0/api/ class=gb-nav-link>API Reference
</a><a href=/v5.1/guides/ class=gb-nav-link>Getting Started Guides
</a><a href=/v6.0/examples/ class=gb-nav-link>Examples
</a><a href=/v5.1/examples/ class=gb-nav-link>Code Examples
</a><a href=/community/ class=gb-nav-link>Community
</a><a href=/v5.1/architecture-diagrams/ class=gb-nav-link>Architecture Diagrams</a></nav></header><aside class=gb-sidebar><nav class=gb-sidebar-nav><div class=gb-sidebar-section><div class=gb-sidebar-title>V6.0s</div><a href=/v6.0/guides/6-0-readiness-status/ class=gb-sidebar-link>GridBuilding 6.0 Readiness Status
</a><a href=/v6.0/guides/getting_started/ class=gb-sidebar-link>Getting Started with GridBuilding
</a><a href=/v6.0/guides/mode-architecture/ class=gb-sidebar-link>GridBuilding 6.0 Mode Architecture
</a><a href=/v6.0/guides/gdscript-to-csharp-mapping/ class=gb-sidebar-link>GDScript to C# Migration Guide
</a><a href=/v6.0/guides/csharp_state_integration/ class=gb-sidebar-link>C# State Integration with Godot Frontend
</a><a href=/v6.0/guides/troubleshooting/ class=gb-sidebar-link>Troubleshooting Guide
</a><a href=/v6.0/examples/godot_integration_example/ class=gb-sidebar-link>Godot Integration Example
</a><a href=/gridbuilding/v6.0-public/guides/dependency-resolution/ class="gb-sidebar-link active">Dependency Resolution in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/userid-quickstart/ class=gb-sidebar-link>Quick Start: Game-Owned UserId & Multi-Owner Orchestrators
</a><a href=/gridbuilding/v6.0-public/guides/building-system-architecture/ class=gb-sidebar-link>BuildingSystem Architecture (Legacy Session Orchestrator)
</a><a href=/gridbuilding/v6.0-public/guides/multi-owner-orchestration-priorities/ class=gb-sidebar-link>Multi-Owner Orchestration Priorities (v6.0)
</a><a href=/gridbuilding/v6.0/guides/placement-system-architecture/ class=gb-sidebar-link>Placement System and Architecture in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/manipulation-system-architecture/ class=gb-sidebar-link>ManipulationSystemNode Architecture (Session Orchestrator)
</a><a href=/v6.0/guides/service_based_architecture/ class=gb-sidebar-link>Service-Based Architecture
</a><a href=/gridbuilding/v6-0/api/ class=gb-sidebar-link>GridBuilding API Reference</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.1.0</div><a href=/v5.1/overview/ class=gb-sidebar-link>Grid Building Plugin Overview
</a><a href=/v5.1/guides/ class=gb-sidebar-link>Getting Started Guides
</a><a href=/v5.1/api/ class=gb-sidebar-link>C# API Reference
</a><a href=/v5.1/examples/ class=gb-sidebar-link>Code Examples
</a><a href=/v5.1/architecture-diagrams/ class=gb-sidebar-link>Architecture Diagrams
</a><a href=/v5.1/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.1/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.1/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.1/validation/ class=gb-sidebar-link>Validation Tools</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.0.0</div><a href=/v5.0/api/ class=gb-sidebar-link>GDScript API Reference
</a><a href=/v5.0/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.0/overview/ class=gb-sidebar-link>Grid Building Plugin v5.0.0
</a><a href=/v5.0/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.0/guides/ class=gb-sidebar-link>Plugin Overview
</a><a href=/v5.0/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.0/validation/ class=gb-sidebar-link>Validation Tools</a></div></nav></aside><main class=gb-main><div class=gb-content><h1>Dependency Resolution in GridBuilding v6.0 (Godot)</h1><blockquote><p><strong>Note:</strong> The v6.0 documentation tracks the in-progress <strong>Grid Placement 6.0 (C#)</strong> line.
It is an internal roadmap/preview and should not be treated as a promised public release or timeline.
The current GDScript release line is <strong>v5.1</strong>.</p></blockquote><h1 id=dependency-resolution-in-gridbuilding-v60-godot>Dependency Resolution in GridBuilding v6.0 (Godot)</h1><p>This guide explains, in practical terms, <strong>how GridBuilding objects find their dependencies</strong> in v6.0: where services come from, how Godot nodes are wired, and what role <code>CompositionContainer</code> still plays.</p><p>The short version:</p><ul><li><strong>ServiceCompositionRoot</strong> builds a <strong>ServiceRegistry</strong>.</li><li><strong>Core services</strong> (pure C#) are registered in that registry.</li><li><strong>Godot systems</strong> (nodes) ask the registry for services instead of creating them directly.</li><li><strong>CompositionContainer</strong> is a compatibility wrapper used where older APIs still expect a &ldquo;container&rdquo; object.</li></ul><hr><h2 id=1-core-concepts>1. Core Concepts</h2><h3 id=11-servicecompositionroot-godot-bootstrap>1.1 ServiceCompositionRoot (Godot bootstrap)</h3><p><code>Godot/Bootstrap/ServiceCompositionRoot.cs</code> is the <strong>entry point</strong> for dependency wiring in v6.0.</p><p>It is a Godot <code>Node</code> you add to your scene. When it enters the tree, it:</p><ol><li>Creates a <code>ServiceRegistry</code> instance.</li><li>Registers <strong>infrastructure</strong> services (logging, validation, etc.).</li><li>Registers <strong>Core services</strong> (pure C#):<ul><li><code>IPlacementValidator</code>, <code>ICollisionCalculator</code></li><li><code>IGridTargetingState</code> (POCS state wrapper)</li><li><code>IPlacementService</code>, <code>IManipulationService</code>, <code>IGridTargetingService</code></li><li><code>IPlacementCommands</code>, <code>IManipulationCommands</code> (high-level command facades)</li></ul></li><li>Registers <strong>Godot services</strong>:<ul><li><code>ISceneService</code> for scene/node operations</li><li><code>IndicatorService</code> for placement indicators</li></ul></li><li>Exposes the registry globally via:<ul><li><code>GetServiceRegistry()</code> on the node instance</li><li><code>static ServiceCompositionRoot.GetGlobalRegistry()</code> helper</li><li><code>static ServiceCompositionRoot.GetGlobalService&lt;T>()</code> helper</li></ul></li></ol><h3 id=12-serviceregistry-coreservicesdi>1.2 ServiceRegistry (Core.Services.DI)</h3><p><code>ServiceRegistry</code> is a <strong>simple dependency injection container</strong> used by the root:</p><ul><li>Keeps track of <strong>singletons</strong> and <strong>factories</strong> for services.</li><li>Provides <code>GetService&lt;T>()</code> and <code>GetService(Type)</code> methods.</li><li>Handles <strong>lifetime</strong>:<ul><li>Singletons (one per registry)</li><li>Factories (created on demand)</li></ul></li></ul><p>Godot systems never need to know <em>how</em> a service is created—only that they can ask the registry for it.</p><h3 id=13-compositioncontainer-godotservicesdi>1.3 CompositionContainer (Godot.Services.DI)</h3><p><code>GridBuilding.Godot.Services.DI.CompositionContainer</code> is a <strong>compatibility wrapper</strong> around newer DI infrastructure.</p><ul><li>It wraps a <code>ServiceRegistry</code> and keeps some of the old, Godot-friendly API:<ul><li><code>GetLogger()</code></li><li><code>GetSystemsContext()</code></li><li><code>GetTargetingState()</code></li><li><code>GetPlacementRules()</code></li><li><code>GetVisualSettings()</code>, <code>GetTemplates()</code></li></ul></li><li>It can be initialized from a <code>.tres</code> resource via <code>InitializeFromTresFile</code>, preserving old workflows.</li><li>It is used by older/legacy-style APIs like:<ul><li><code>IndicatorService.CreateWithInjection(CompositionContainer, Node)</code></li><li><code>PlacementValidator.CreateWithInjection(CompositionContainer)</code></li><li><code>PlacementSystem.Legacy.CreateWithInjection(CompositionContainer)</code></li></ul></li></ul><p>You should treat <code>CompositionContainer</code> as:</p><blockquote><p>&ldquo;A bridge for older container-based code, implemented on top of the new ServiceRegistry.&rdquo;</p></blockquote><p>Newer code should prefer <strong>direct access</strong> to <code>ServiceRegistry</code> via <code>ServiceCompositionRoot</code>.</p><hr><h2 id=2-how-godot-nodes-resolve-dependencies>2. How Godot Nodes Resolve Dependencies</h2><h3 id=21-new-pattern-ask-servicecompositionroot--serviceregistry>2.1 New pattern: ask ServiceCompositionRoot / ServiceRegistry</h3><p>Modern systems (e.g. the v6.0 <code>PlacementSystem</code>) resolve dependencies like this:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>override</span> <span style=color:#ff7b72>void</span> _Ready() {
</span></span><span style=display:flex><span>  GD.Print(<span style=color:#a5d6ff>&#34;Initializing PlacementSystem with Enhanced Service Registry...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// Locate ServiceCompositionRoot</span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> serviceRoot = FindServiceCompositionRoot();
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>if</span> (serviceRoot == <span style=color:#79c0ff>null</span>) {
</span></span><span style=display:flex><span>    GD.PrintErr(<span style=color:#a5d6ff>&#34;ServiceCompositionRoot not found.&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> registry = serviceRoot.GetServiceRegistry();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// Resolve Core + Godot services</span>
</span></span><span style=display:flex><span>  _placementService = serviceRoot.GetService&lt;IPlacementService&gt;();
</span></span><span style=display:flex><span>  _sceneService     = serviceRoot.GetService&lt;ISceneService&gt;();
</span></span><span style=display:flex><span>  _indicatorService = serviceRoot.GetService&lt;IndicatorService&gt;();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Key points:</p><ul><li>The system <strong>does not new up</strong> its own services.</li><li>It <strong>finds the nearest <code>ServiceCompositionRoot</code></strong>, then asks for services.</li><li>The <strong>Pure C# logic</strong> stays in Core services (<code>IPlacementService</code>, <code>IGridTargetingService</code>), while the node orchestrates Godot-specific behavior.</li></ul><h3 id=211-key-runtime-services-what-they-do-and-consume>2.1.1 Key runtime services (what they do and consume)</h3><p>At runtime, a small set of services are central to placement flows:</p><ul><li><p><strong><code>IPlacementService</code> (Core.Services.Placement)</strong></p><ul><li><strong>Role:</strong> Pure C# placement engine (validate + execute placement, remove/move objects, query occupancy).</li><li><strong>Consumes:</strong><ul><li><code>IPlacementValidator</code> (rule checks: bounds, collisions, tile policies).</li><li><code>ICollisionCalculator</code> (geometry/collision math in Core).</li><li><code>IGridTargetingState</code> (current grid, tile, and owner context).</li></ul></li><li><strong>Produces:</strong><ul><li><code>PlacementReport</code> (detailed validation results).</li><li><code>PlacementResult</code> (success flag, errors, and placed-instance metadata for the Godot layer to consume).</li></ul></li></ul></li><li><p><strong><code>IPlacementCommands</code> / <code>IManipulationCommands</code> (Core.Interfaces)</strong></p><ul><li><strong>Role:</strong> High-level, user-scoped command facades over <code>IPlacementService</code> and <code>IManipulationService</code>.</li><li><strong>Consumes:</strong><ul><li><code>IPlacementService</code> / <code>IManipulationService</code> from the service registry.</li></ul></li><li><strong>Produces:</strong><ul><li><code>PlacementResult</code> / <code>ManipulationResult</code> for controllers and UI.</li></ul></li><li>Controllers and session/owner roots call these interfaces first, instead of
directly invoking the lower-level services.</li></ul></li><li><p><strong><code>PlacementSystem</code> (Godot.Systems.Placement)</strong></p><ul><li><strong>Role:</strong> Lightweight Godot <code>Node</code> that orchestrates placement using the Enhanced Service Registry pattern.</li><li><strong>Consumes:</strong><ul><li><code>IPlacementService</code> from <code>ServiceCompositionRoot</code>.</li><li><code>ISceneService</code> (instantiates scenes, sets positions, attaches to tree).</li><li><code>IndicatorService</code> (drives rule-check indicators after validation).</li></ul></li><li><strong>Produces:</strong><ul><li>Final <code>PlacementReport</code> for callers (UI, behaviors, tests).</li><li>Instantiated Godot nodes for successful placements (via <code>ISceneService</code>).</li></ul></li></ul></li><li><p><strong><code>IndicatorService</code> (Godot.Systems.Placement.Managers)</strong></p><ul><li><strong>Role:</strong> Manages <code>RuleCheckIndicator</code> nodes for visual feedback during placement.</li><li><strong>Consumes:</strong><ul><li><code>GridTargetingState</code> (to know where indicators should be placed).</li><li>Indicator templates from <code>CompositionContainer</code> / templates resources.</li><li><code>CollisionMapper</code> and placement utilities for geometry and contact points.</li><li><code>Logger</code> for diagnostics.</li></ul></li><li><strong>Produces:</strong><ul><li>Indicator nodes under a given parent.</li><li>Diagnostic reports via <code>IndicatorSetupReport</code> and logs.</li></ul></li></ul></li></ul><blockquote><p><strong>Note:</strong> Older building-centric services like <code>BuildingService</code>, <code>IBuildingService</code>, and <code>BuildingBehavior</code> are now marked as obsolete. New code should drive placement via <code>PlacementSystem</code> + <code>IPlacementService</code> and, where needed, a placement-focused behavior that talks to those services.</p></blockquote><h3 id=22-legacy-pattern-pass-a-compositioncontainer-in>2.2 Legacy pattern: pass a CompositionContainer in</h3><p>Some older systems and helpers still expose <code>CreateWithInjection</code> or <code>ResolveGBDependencies</code> methods that take a container:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// IndicatorService</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> IndicatorService CreateWithInjection(CompositionContainer container, Node parent) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> targetingState = container.GetTargetingState();
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> logger         = container.GetLogger();
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> template       = container.GetTemplates().RuleCheckIndicator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> service = <span style=color:#ff7b72>new</span> IndicatorService(parent, targetingState, template, logger);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// Optional additional injection / validation</span>
</span></span><span style=display:flex><span>  service.ResolveGbDependencies(container);
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> issues = service.GetRuntimeIssues();
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>if</span> (issues.Count &gt; <span style=color:#a5d6ff>0</span>) {
</span></span><span style=display:flex><span>    logger?.LogWarnings(issues);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>return</span> service;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>In this pattern:</p><ul><li>Your <strong>bootstrap code</strong> (or tests) create a <code>CompositionContainer</code> and initialize it.</li><li>That container is then passed into any object that still uses container-based injection.</li><li>Inside those methods, the container simply <strong>forwards to the underlying ServiceRegistry</strong>.</li></ul><h3 id=23-example-targetinformer-ui-component>2.3 Example: TargetInformer UI component</h3><p><code>TargetInformer</code> is a UI control that displays <strong>what the player is currently interacting with</strong> (manipulation, building preview, or targeting):</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> ResolveGBDependencies(CompositionContainer container) {
</span></span><span style=display:flex><span>  _DisconnectAllSignals();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>var</span> states = container.GetStates();
</span></span><span style=display:flex><span>  _buildingState     = states.Building;
</span></span><span style=display:flex><span>  _manipulationState = states.Manipulation;
</span></span><span style=display:flex><span>  _targetingState    = states.Targeting;
</span></span><span style=display:flex><span>  ModeState          = states.Mode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  _settings = container.GetVisualSettings().TargetInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// Hook into state change events to refresh the display</span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// (wiring omitted here for brevity)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Where does <code>container</code> come from?</p><ul><li>In your <strong>game bootstrap</strong> or <strong>test setup</strong>, you:<ul><li>Construct and initialize a <code>CompositionContainer</code>.</li><li>Pass it into <code>TargetInformer.ResolveGBDependencies(container)</code> after adding the node to the tree.</li></ul></li></ul><hr><h2 id=3-how-tests-resolve-dependencies>3. How Tests Resolve Dependencies</h2><h3 id=31-core-tests-pure-c>3.1 Core tests (pure C#)</h3><p>Core xUnit tests <strong>never touch Godot</strong> and do not use <code>CompositionContainer</code>. Instead, they:</p><ul><li>New up <strong>Core services</strong> directly (or via a small test-only registry).</li><li>Assert behavior of:<ul><li><code>IPlacementService</code></li><li><code>GridTargetingService</code></li><li><code>PlacementReport</code>, <code>PlacementResult</code></li><li>Rule validation helpers</li></ul></li></ul><h3 id=32-godot-tests-godottest--chickensoft>3.2 Godot tests (GoDotTest / Chickensoft)</h3><p>Godot integration tests follow the same patterns as runtime code, but in a test environment:</p><ul><li>Use a minimal scene with <strong>ServiceCompositionRoot</strong> wired.</li><li>Or create/initialize a <strong>test CompositionContainer</strong> and call <code>CreateWithInjection</code> helpers.</li><li>Use GoDotTest to <strong>spin up nodes, call methods, and assert on Godot behavior</strong>.</li></ul><p>Example for placement validation in a test:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff7b72>var</span> container = <span style=color:#ff7b72>new</span> CompositionContainer();
</span></span><span style=display:flex><span>container.Initialize();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> parent = <span style=color:#ff7b72>new</span> Node();
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> indicatorService = IndicatorService.CreateWithInjection(container, parent);
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> validator        = PlacementValidator.CreateWithInjection(container);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// Run placement validation and assert on results</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=4-when-should-i-use-which-pattern>4. When Should I Use Which Pattern?</h2><h3 id=prefer-servicecompositionroot--serviceregistry-when>Prefer <strong>ServiceCompositionRoot + ServiceRegistry</strong> when:</h3><ul><li>You are building <strong>new systems</strong> in v6.0.</li><li>You want <strong>clean separation</strong> between Core logic and Godot nodes.</li><li>You want easier <strong>testing of Core services</strong> without Godot.</li></ul><h3 id=use-compositioncontainer-when>Use <strong>CompositionContainer</strong> when:</h3><ul><li>You are working with <strong>legacy systems</strong> that still expect a container object.</li><li>You are porting GDScript/GdUnit tests or scenes that use <code>GBCompositionContainer.tres</code>.</li><li>You need to bridge older <code>.tres</code> configuration into the new service world.</li></ul><p>Over time, more APIs will move to the <strong>ServiceCompositionRoot + ServiceRegistry</strong> pattern, and <code>CompositionContainer</code> will remain mainly as a compatibility layer for existing content.</p><hr><h2 id=5-summary>5. Summary</h2><ul><li><code>ServiceCompositionRoot</code> builds and owns the <strong>ServiceRegistry</strong>.</li><li>Core services (<code>IPlacementService</code>, <code>IGridTargetingService</code>, etc.) are registered there.</li><li>Godot systems either:<ul><li>Resolve services directly from <code>ServiceCompositionRoot</code> <strong>(new pattern)</strong>, or</li><li>Accept a <code>CompositionContainer</code> that wraps those services <strong>(legacy pattern)</strong>.</li></ul></li><li>Tests can use the same mechanisms: Core tests construct services directly; Godot tests use the root or a test <code>CompositionContainer</code>.</li></ul><p>This is the v6.0-supported way GridBuilding resolves dependencies and keeps Core logic engine-agnostic.</p><hr><h2 id=6-owners-and-multi-tenant-dependency-resolution-design-direction>6. Owners and Multi-Tenant Dependency Resolution (Design Direction)</h2><p>Status: This section documents the intended architecture for multi-owner and multiplayer setups in v6.x. Some elements are still in progress and tracked in internal docs.</p><h3 id=61-what-is-an-owner>6.1 What is an Owner</h3><p>In GridBuilding, an Owner is any participant that can control or own buildings and actions in a session:</p><ul><li>Human local player</li><li>AI controller</li><li>Special or system side such as neutral or environment</li></ul><p>Owners are not limited to human players. The API and dependency lifetimes are designed around this generic owner concept.</p><h3 id=62-lifetimes-process-session-owner>6.2 Lifetimes: Process, Session, Owner</h3><p>To support multiple sessions and multiple owners per session, GridBuilding uses three layers of lifetime:</p><ul><li><p>Process lifetime</p><ul><li>Lives for the lifetime of the game process</li><li>Holds shared infrastructure such as logging, configuration, factories, serialization</li><li>Knows which modules or plugins are available</li></ul></li><li><p>Session lifetime</p><ul><li>One session scope per game session, match, or world</li><li>Shared across all owners in that session</li><li>Holds session state such as world or grid state, rules, shared services</li></ul></li><li><p>Owner lifetime</p><ul><li>One owner scope per combination of session and owner</li><li>Holds per-owner state such as selection and preview state, build queues, and owner UI or controllers</li></ul></li></ul><p>A simple way to visualize this is:</p><p>Process services
Session services per session
Owner services per owner in a session</p><p>ServiceCompositionRoot and ServiceRegistry remain the core mechanisms, but are extended to support session and owner scopes instead of a single global registry.</p><h3 id=63-plugin-modules-and-registration>6.3 Plugin modules and registration</h3><p>Plugins, including the GridBuilding plugin itself, do not create their own composition roots. Instead, each plugin exposes a module that can register services at the appropriate lifetimes.</p><p>At startup and during session or owner creation, the framework:</p><ol><li>Discovers all module implementations</li><li>Calls registration methods such as:<ul><li>Register process services once at process bootstrap</li><li>Register session services once per new session</li><li>Register owner services once per new owner in that session</li></ul></li></ol><p>This keeps plugin wiring centralized and consistent while still allowing each plugin to define what it needs per lifetime.</p><h3 id=64-owner-registration-flow>6.4 Owner registration flow</h3><p>To participate in GridBuilding, a game or higher-level framework creates owners through a single canonical API. Conceptually the flow is:</p><ol><li>Create a session for a world or match using a session manager</li><li>Create an owner in that session using an owner configuration</li><li>Internally, the owner creation<ul><li>Creates an owner scope under the session scope</li><li>Invokes all plugin modules so they can register owner services</li><li>Returns an owner handle or identifier for later use</li></ul></li></ol><p>On the Godot side, this is paired with a SessionRoot and OwnerRoot node pattern.</p><ul><li>A SessionRoot node represents the session in the scene tree</li><li>Under SessionRoot, there is one OwnerRoot node per owner</li><li>Each OwnerRoot marks a subtree as belonging to a specific owner</li><li>Nodes under an OwnerRoot do not create services directly, they ask the framework to inject dependencies from their owner scope</li></ul><h3 id=65-quickstart-gridbuildingcompositionroot>6.5 Quickstart: GridBuildingCompositionRoot</h3><p>For simple single-owner setups such as tutorials or standalone prototypes, you can still use an optional GridBuildingCompositionRoot node.</p><p>This node:</p><ul><li>Creates a minimal session and owner on its own</li><li>Registers GridBuilding session and owner services</li><li>Wires a basic scene for a single controlling side</li></ul><p>This should be treated as a convenience bootstrap for GridBuilding only scenes. For multi-plugin or advanced multiplayer scenarios, prefer the central session and owner APIs described above.</p><h3 id=67-game-owned-userid-and-plugin-integration-public-guidance>6.7 Game-owned UserId and plugin integration (public guidance)</h3><p>In v6.x, <strong>user identity is game-owned</strong>, and GridBuilding treats <code>UserId</code> as an opaque handle that answers:</p><blockquote><p><em>“Which user/owner is this command or UI element acting on behalf of?”</em></p></blockquote><p>There are two practical integration patterns for plugin consumers:</p><h4 id=671-simple-setup--single-local-user>6.7.1 Simple setup – single local user</h4><p>Use this for prototypes or games with a single local player.</p><ul><li><strong>Scene wiring</strong><ul><li>Add <code>ServiceCompositionRoot</code> to your main scene so the <strong>ServiceRegistry</strong> exists.</li><li>Add the GridBuilding nodes you need (targeting, placement, manipulation, HUD).</li></ul></li><li><strong>Create a single <code>UserId</code> in your game code</strong><ul><li>Your game allocates a <code>UserId</code> for the local player (for example via a constructor or helper in your own code).</li><li>You then always pass that <code>UserId</code> into GridBuilding’s <strong>command facades</strong>:<ul><li><code>IPlacementCommands.TryPlace(userId, ...)</code></li><li><code>IPlacementCommands.TryDemolish(userId, ...)</code></li><li><code>IManipulationCommands.TryMove(userId, ...)</code>, etc.</li></ul></li><li>For UI that has been made user-aware (e.g. v6 <code>TargetInformer</code>, <code>ActionLog</code>), you initialize them with:<ul><li><code>TargetInformer.InitializeForUser(userId, ...)</code></li><li><code>ActionLog.InitializeForUser(userId, ...)</code>.</li></ul></li></ul></li><li><strong>What lives where</strong><ul><li>GridBuilding owns <strong>services and systems</strong> via <code>ServiceCompositionRoot</code> and <code>ServiceRegistry</code>.</li><li>Your game owns <strong>who the user is</strong> and which <code>UserId</code> to use.</li></ul></li></ul><p>This keeps setup straightforward while matching the v6 owner/session design.</p><h4 id=672-advanced-setup--multi-owner-and-multiplayer>6.7.2 Advanced setup – multi-owner and multiplayer</h4><p>For splitscreen, networked games, AI, or tools, you typically move to a
<strong>game-owned session/owner model</strong> that coordinates all <code>UserId</code>s.</p><ul><li><strong>Game/session model owns identity</strong><ul><li>Define game-side types such as <code>PlayerSession</code> or <code>GameUserSession</code> that store:<ul><li>Engine or network identifiers (controller index, peer ID, account ID, etc.).</li><li>The corresponding GridBuilding <code>UserId</code>.</li></ul></li><li>Maintain a small registry (e.g. <code>PlayerSessionManager</code>) that maps from engine/network IDs to <code>UserId</code>.</li></ul></li><li><strong>Bootstrap + services</strong><ul><li>Continue to use <code>ServiceCompositionRoot</code> (or a central game bootstrap) to register GridBuilding services.</li><li>During session/owner creation your game:<ul><li>Creates the required <code>UserId</code>s for each owner.</li><li>Resolves <code>IPlacementCommands</code>, <code>IManipulationCommands</code>, and other services from the registry.</li><li>Wires controllers and HUD by passing in the correct <code>UserId</code>.</li></ul></li></ul></li><li><strong>Per-owner controllers and UI</strong><ul><li>Owner-level controllers (per player or per character) read input and consult the game’s owner/session model to obtain the right <code>UserId</code>.</li><li>They call the shared systems/commands with that <code>UserId</code> and targeting data.</li><li>Per-owner HUD (target info, action log, etc.) is initialized with <code>InitializeForUser(userId, ...)</code> so that each HUD clearly represents a specific user.</li></ul></li></ul><p>GridBuilding remains <strong>engine/network agnostic</strong>: it never derives users from scene tree names, peer IDs, or controllers. It only sees <code>UserId</code> and relies on your game to decide what that means.</p><h4 id=673-compositioncontainer-and-legacy-scope-nodes>6.7.3 CompositionContainer and legacy scope nodes</h4><p><code>CompositionContainer</code> and older scope-style helpers are still available, but primarily as
<strong>migration and test scaffolding</strong>:</p><ul><li>They provide a convenient way to stand up services and state for older projects or tests that expect a container object.</li><li>Internally, they forward to the same <code>ServiceRegistry</code> built by <code>ServiceCompositionRoot</code>.</li><li>They should <strong>not</strong> be the primary owner of user/session identity in new games.</li></ul><p>For new or actively maintained projects:</p><ul><li>Prefer <strong>game-owned <code>UserId</code> + ServiceCompositionRoot</strong> and the session/owner patterns described above.</li><li>Use <code>CompositionContainer</code> in tests and legacy content where refactoring to the new pattern is not yet complete.</li></ul><h4 id=674-targetingshapecast2d-and-per-user-targeting>6.7.4 TargetingShapeCast2D and per-user targeting</h4><p><code>TargetingShapeCast2D</code> is the Godot-side physics component that drives <strong>what the user is looking at on the grid</strong>. It does <strong>not</strong> know about <code>UserId</code> directly. Instead, it updates an owner-scoped <code>GridTargetingState</code>, and the service layer associates that state with a specific <code>UserId</code>.</p><p>At a high level:</p><ul><li>The <strong>game</strong> owns <code>UserId</code> and a session/owner model.</li><li>GridBuilding creates an <strong>owner scope per (session, UserId)</strong> that includes:<ul><li><code>IGridTargetingState</code> (Core)</li><li>A Godot <code>GridTargetingState</code> / <code>GBCompositionContainer</code> bound to that owner.</li></ul></li><li><code>TargetingShapeCast2D</code> is wired to the <strong>owner’s targeting state</strong> via dependency resolution.</li></ul><h5 id=node-layout-not-parented-under-the-player>Node layout (not parented under the player)</h5><p>Per owner, a typical scene layout is:</p><ul><li><code>SessionRoot</code> (represents the game session)<ul><li><code>OwnerRoot</code> (represents one owner/user)<ul><li><code>Character</code> (optional: player character / pawn)</li><li><code>GridBuildingCursorRoot</code> (cursor / targeting stack)<ul><li><code>TargetingShapeCast2D</code></li><li>Optional cursor visuals</li></ul></li></ul></li></ul></li></ul><p><code>TargetingShapeCast2D</code> is <strong>not</strong> a child of the player character. Its transform is driven by input:</p><ul><li>Mouse input: move <code>GridBuildingCursorRoot</code> to the mouse world position.</li><li>Keyboard / gamepad: move in discrete grid steps.</li><li>AI: move according to AI decisions.</li></ul><p>The ShapeCast only cares about <strong>where</strong> it is in the world, not who moved it.</p><h5 id=how-targetingshapecast2d-becomes-per-user>How TargetingShapeCast2D becomes per-user</h5><p>Per owner:</p><ol><li><p>The game creates a <code>UserId</code> and an owner scope (see sections 6.4–6.7).</p></li><li><p>During bootstrap, GridBuilding registers:</p><ul><li>An <code>IGridTargetingState</code> for that owner.</li><li>A Godot <code>GridTargetingState</code> / <code>GBCompositionContainer</code> bound to the same owner.</li></ul></li><li><p>In Godot, a per-owner cursor/controller node:</p><ul><li><p>Knows which <code>UserId</code> it represents (from the game’s session model).</p></li><li><p>Resolves <code>ServiceCompositionRoot</code> and the owner’s container/state using that <code>UserId</code>.</p></li><li><p>Calls something conceptually like:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Pseudocode</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>var</span> container_for_owner <span style=color:#ff7b72;font-weight:700>=</span> OwnerService<span style=color:#ff7b72;font-weight:700>.</span><span style=color:#d2a8ff;font-weight:700>resolve_container_for_user</span>(user_id)
</span></span><span style=display:flex><span>targeting_shape_cast<span style=color:#ff7b72;font-weight:700>.</span><span style=color:#d2a8ff;font-weight:700>resolve_gb_dependencies</span>(container_for_owner)
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>From this point on:</p><ul><li><code>TargetingShapeCast2D</code> updates <strong>that owner’s</strong> <code>GridTargetingState</code>.</li><li>Core commands (<code>IPlacementCommands</code>, <code>IManipulationCommands</code>) use the same owner-scoped targeting state when called with that <code>UserId</code>.</li></ul></li></ol><p>The ShapeCast does not store or export a <code>UserId</code>. Its effective identity is derived entirely from <strong>which targeting state it is bound to</strong>, and that targeting state is owner-scoped in the service layer.</p><h5 id=human-ai-and-multi-player>Human, AI, and multi-player</h5><p>This pattern works the same way regardless of input source:</p><ul><li><strong>Human local player</strong>: controller reads input, looks up the correct <code>UserId</code>, and moves the cursor root.</li><li><strong>AI controller</strong>: AI logic decides a desired grid position and moves the cursor root programmatically.</li><li><strong>Multiplayer / splitscreen</strong>: each owner has its own:<ul><li><code>UserId</code></li><li>Owner scope in the service layer</li><li><code>GridBuildingCursorRoot</code> + <code>TargetingShapeCast2D</code> bound to that owner’s targeting state</li></ul></li></ul><p>GridBuilding itself remains <strong>user-id-centric and engine-agnostic</strong>:</p><ul><li>It never inspects scene paths or node names to figure out &ldquo;which player&rdquo;.</li><li>It sees <code>UserId</code> at the command/service layer.</li><li>Godot-side components like <code>TargetingShapeCast2D</code> become per-user by being wired to the correct <strong>owner-scoped targeting state</strong>, not by their position in the node hierarchy.</li></ul><h4 id=675-per-user-runtime-state-objects-and-orchestrator-services>6.7.5 Per-user runtime state objects and orchestrator services</h4><p>In the owner-scoped model, <strong>each user has its own copy of the key runtime “state” objects</strong>, and <strong>services/command facades orchestrate across all users</strong>:</p><ul><li><p><strong>Per-user state (one instance per (session, UserId))</strong></p><ul><li><code>GridTargetingState</code> – what this user is currently pointing at, which map(s) they are targeting, tile size, collision exclusions.</li><li><code>ManipulationState</code> – what this user is currently manipulating (move/rotate/flip), current operation state.</li><li><code>ModeState</code> – this user’s current building/mode (build, move, demolish, info, etc.).</li><li>(Deprecated) <code>BuildingState</code> – per-building runtime state, not per-user; kept for legacy visualizers and will be replaced by newer placement-centric state.</li></ul></li><li><p><strong>Orchestrator services (multi-user aware)</strong></p><ul><li><code>IPlacementCommands</code> / <code>IManipulationCommands</code> take <code>UserId</code> and route work to the <strong>correct per-user state</strong> and core services.</li><li><code>IGridTargetingService</code> and other core services operate over grid/navigation data and <strong>consume per-user state via session/owner scopes</strong> rather than Godot nodes.</li></ul></li></ul><p>The intent for v6.x is that:</p><ul><li><strong>Controllers and UI are per-user</strong> and always call command facades with a <code>UserId</code>.</li><li><strong>Session/owner scopes</strong> hold the per-user state instances (targeting, manipulation, mode) for that <code>UserId</code>.</li><li><strong>Services/commands</strong> act as <strong>orchestrators over all users</strong> by accepting <code>UserId</code> and resolving the appropriate owner scope, instead of being tied to a single global targeting/mode state.</li></ul></div></main><aside class=gb-toc><div class=gb-toc-title>On this page</div><nav id=TableOfContents><ul><li><a href=#1-core-concepts>1. Core Concepts</a><ul><li><a href=#11-servicecompositionroot-godot-bootstrap>1.1 ServiceCompositionRoot (Godot bootstrap)</a></li><li><a href=#12-serviceregistry-coreservicesdi>1.2 ServiceRegistry (Core.Services.DI)</a></li><li><a href=#13-compositioncontainer-godotservicesdi>1.3 CompositionContainer (Godot.Services.DI)</a></li></ul></li><li><a href=#2-how-godot-nodes-resolve-dependencies>2. How Godot Nodes Resolve Dependencies</a><ul><li><a href=#21-new-pattern-ask-servicecompositionroot--serviceregistry>2.1 New pattern: ask ServiceCompositionRoot / ServiceRegistry</a></li><li><a href=#211-key-runtime-services-what-they-do-and-consume>2.1.1 Key runtime services (what they do and consume)</a></li><li><a href=#22-legacy-pattern-pass-a-compositioncontainer-in>2.2 Legacy pattern: pass a CompositionContainer in</a></li><li><a href=#23-example-targetinformer-ui-component>2.3 Example: TargetInformer UI component</a></li></ul></li><li><a href=#3-how-tests-resolve-dependencies>3. How Tests Resolve Dependencies</a><ul><li><a href=#31-core-tests-pure-c>3.1 Core tests (pure C#)</a></li><li><a href=#32-godot-tests-godottest--chickensoft>3.2 Godot tests (GoDotTest / Chickensoft)</a></li></ul></li><li><a href=#4-when-should-i-use-which-pattern>4. When Should I Use Which Pattern?</a><ul><li><a href=#prefer-servicecompositionroot--serviceregistry-when>Prefer <strong>ServiceCompositionRoot + ServiceRegistry</strong> when:</a></li><li><a href=#use-compositioncontainer-when>Use <strong>CompositionContainer</strong> when:</a></li></ul></li><li><a href=#5-summary>5. Summary</a></li><li><a href=#6-owners-and-multi-tenant-dependency-resolution-design-direction>6. Owners and Multi-Tenant Dependency Resolution (Design Direction)</a><ul><li><a href=#61-what-is-an-owner>6.1 What is an Owner</a></li><li><a href=#62-lifetimes-process-session-owner>6.2 Lifetimes: Process, Session, Owner</a></li><li><a href=#63-plugin-modules-and-registration>6.3 Plugin modules and registration</a></li><li><a href=#64-owner-registration-flow>6.4 Owner registration flow</a></li><li><a href=#65-quickstart-gridbuildingcompositionroot>6.5 Quickstart: GridBuildingCompositionRoot</a></li><li><a href=#67-game-owned-userid-and-plugin-integration-public-guidance>6.7 Game-owned UserId and plugin integration (public guidance)</a><ul><li><a href=#671-simple-setup--single-local-user>6.7.1 Simple setup – single local user</a></li><li><a href=#672-advanced-setup--multi-owner-and-multiplayer>6.7.2 Advanced setup – multi-owner and multiplayer</a></li><li><a href=#673-compositioncontainer-and-legacy-scope-nodes>6.7.3 CompositionContainer and legacy scope nodes</a></li><li><a href=#674-targetingshapecast2d-and-per-user-targeting>6.7.4 TargetingShapeCast2D and per-user targeting</a></li><li><a href=#675-per-user-runtime-state-objects-and-orchestrator-services>6.7.5 Per-user runtime state objects and orchestrator services</a></li></ul></li></ul></li></ul></nav></aside><footer class=gb-footer><p>&copy; 2025 Chris Tutorials. All rights reserved.</p><p>Built with <a href=https://gohugo.io/ target=_blank>Hugo</a> and
<a href=https://godotengine.org/ target=_blank>Godot</a>.</p></footer></div></body></html>