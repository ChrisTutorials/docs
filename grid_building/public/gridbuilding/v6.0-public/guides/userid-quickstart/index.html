<!doctype html><html lang=en-us><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Quick Start: Game-Owned UserId & Multi-Owner Orchestrators | GridBuilding Plugin</title>
<meta name=description content="How to wire GridBuilding v6.0 into your game using a game-owned UserId and shared Building/Manipulation systems."><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><link rel=stylesheet href=/css/custom.css><meta name=generator content="Hugo 0.146.5"></head><body><div class=gb-layout><header class=gb-header><a href=/ class=gb-brand><i class="fas fa-cubes" style=color:var(--gb-primary)></i>
<span>GridBuilding Plugin</span></a><div class=gb-search><i class="fas fa-search"></i>
<input type=text placeholder="Search documentation..." aria-label=Search></div><nav class=gb-nav><a href=/ class=gb-nav-link>Home
</a><a href=/v6.0/overview/ class=gb-nav-link>Documentation
</a><a href=/v5.1/overview/ class=gb-nav-link>Grid Building Plugin Overview
</a><a href=/v6.0/api/ class=gb-nav-link>API Reference
</a><a href=/v5.1/guides/ class=gb-nav-link>Getting Started Guides
</a><a href=/v6.0/examples/ class=gb-nav-link>Examples
</a><a href=/v5.1/examples/ class=gb-nav-link>Code Examples
</a><a href=/community/ class=gb-nav-link>Community
</a><a href=/v5.1/architecture-diagrams/ class=gb-nav-link>Architecture Diagrams</a></nav></header><aside class=gb-sidebar><nav class=gb-sidebar-nav><div class=gb-sidebar-section><div class=gb-sidebar-title>V6.0s</div><a href=/v6.0/guides/6-0-readiness-status/ class=gb-sidebar-link>GridBuilding 6.0 Readiness Status
</a><a href=/v6.0/guides/getting_started/ class=gb-sidebar-link>Getting Started with GridBuilding
</a><a href=/v6.0/guides/mode-architecture/ class=gb-sidebar-link>GridBuilding 6.0 Mode Architecture
</a><a href=/v6.0/guides/gdscript-to-csharp-mapping/ class=gb-sidebar-link>GDScript to C# Migration Guide
</a><a href=/v6.0/guides/csharp_state_integration/ class=gb-sidebar-link>C# State Integration with Godot Frontend
</a><a href=/v6.0/guides/troubleshooting/ class=gb-sidebar-link>Troubleshooting Guide
</a><a href=/v6.0/examples/godot_integration_example/ class=gb-sidebar-link>Godot Integration Example
</a><a href=/gridbuilding/v6.0-public/guides/dependency-resolution/ class=gb-sidebar-link>Dependency Resolution in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/userid-quickstart/ class="gb-sidebar-link active">Quick Start: Game-Owned UserId & Multi-Owner Orchestrators
</a><a href=/gridbuilding/v6.0-public/guides/building-system-architecture/ class=gb-sidebar-link>BuildingSystem Architecture (Legacy Session Orchestrator)
</a><a href=/gridbuilding/v6.0-public/guides/multi-owner-orchestration-priorities/ class=gb-sidebar-link>Multi-Owner Orchestration Priorities (v6.0)
</a><a href=/gridbuilding/v6.0/guides/placement-system-architecture/ class=gb-sidebar-link>Placement System and Architecture in GridBuilding v6.0 (Godot)
</a><a href=/gridbuilding/v6.0-public/guides/manipulation-system-architecture/ class=gb-sidebar-link>ManipulationSystemNode Architecture (Session Orchestrator)
</a><a href=/v6.0/guides/service_based_architecture/ class=gb-sidebar-link>Service-Based Architecture
</a><a href=/gridbuilding/v6-0/api/ class=gb-sidebar-link>GridBuilding API Reference</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.1.0</div><a href=/v5.1/overview/ class=gb-sidebar-link>Grid Building Plugin Overview
</a><a href=/v5.1/guides/ class=gb-sidebar-link>Getting Started Guides
</a><a href=/v5.1/api/ class=gb-sidebar-link>C# API Reference
</a><a href=/v5.1/examples/ class=gb-sidebar-link>Code Examples
</a><a href=/v5.1/architecture-diagrams/ class=gb-sidebar-link>Architecture Diagrams
</a><a href=/v5.1/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.1/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.1/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.1/validation/ class=gb-sidebar-link>Validation Tools</a></div><div class=gb-sidebar-section><div class=gb-sidebar-title>Grid Building Plugin v5.0.0</div><a href=/v5.0/api/ class=gb-sidebar-link>GDScript API Reference
</a><a href=/v5.0/debugging/ class=gb-sidebar-link>Debug Tools
</a><a href=/v5.0/overview/ class=gb-sidebar-link>Grid Building Plugin v5.0.0
</a><a href=/v5.0/migration/ class=gb-sidebar-link>Migration Guide
</a><a href=/v5.0/guides/ class=gb-sidebar-link>Plugin Overview
</a><a href=/v5.0/testing/ class=gb-sidebar-link>Testing
</a><a href=/v5.0/validation/ class=gb-sidebar-link>Validation Tools</a></div></nav></aside><main class=gb-main><div class=gb-content><h1>Quick Start: Game-Owned UserId & Multi-Owner Orchestrators</h1><blockquote><p><strong>Note:</strong> The v6.0 documentation tracks the in-progress <strong>Grid Placement 6.0 (C#)</strong> line.
It is an internal roadmap/preview and should not be treated as a promised public release or timeline.
The current GDScript release line is <strong>v5.1</strong>.</p></blockquote><h1 id=quick-start-game-owned-userid--multi-owner-orchestrators>Quick Start: Game-Owned UserId & Multi-Owner Orchestrators</h1><p>This guide shows how to hook the GridBuilding v6.0 architecture into <strong>your game</strong> using a
<strong>game-owned <code>UserId</code></strong> and <strong>shared session-level systems</strong>:</p><ul><li>One <strong>Building/Placement system</strong> for the whole game session.</li><li>One <strong>Manipulation system</strong> (<code>ManipulationSystemNode</code>) for the whole session.</li><li>One <strong>targeting node per user</strong> (e.g. <code>TargetingShapeCast2D</code> for each camera/player).</li><li>Game code owns <code>UserId</code> and passes it into command facades and UI.</li></ul><p>It is forward-looking: some details may still be under active development in v6.x, but the
overall shape is stable and matches the dependency-resolution and multi-owner guides.</p><hr><h2 id=1-architecture-in-one-minute>1. Architecture in One Minute</h2><p>At runtime, a typical scene looks like this:</p><ul><li><strong>Session-level orchestrators (one each per game session):</strong><ul><li><code>BuildingSystem</code> / placement pipeline</li><li><code>ManipulationSystemNode</code></li><li>Grid/targeting services registered through <code>ServiceCompositionRoot</code></li></ul></li><li><strong>Per-user / per-owner components (one set per user):</strong><ul><li>A targeting node such as <code>TargetingShapeCast2D</code> aligned with that user’s camera/view.</li><li>Input/controller script that turns input + targeting into GridBuilding commands.</li><li>UI elements (HUD, target info, action log) initialized <strong>for that user</strong>.</li></ul></li><li><strong>Game-owned identity:</strong><ul><li>Your game defines one <code>UserId</code> per player/owner.</li><li>All GridBuilding commands and user-aware UI take that <code>UserId</code> as the first argument.</li></ul></li></ul><p>The Core APIs that surface this are:</p><ul><li><code>IPlacementCommands.TryPlace(UserId userId, Placeable placeable, Vector2 worldPosition)</code></li><li><code>IPlacementCommands.TryDemolish(UserId userId, Vector2 worldPosition)</code></li><li><code>IManipulationCommands.TryMove(UserId userId, Vector2I from, Vector2I to)</code></li><li><code>IManipulationCommands.TryRotateLeft/Right(UserId userId, Vector2I origin)</code></li><li><code>IManipulationCommands.TryFlipHorizontal/Vertical(UserId userId, Vector2I origin)</code></li></ul><hr><h2 id=2-single-user-quick-start>2. Single-User Quick Start</h2><p>Use this when you are prototyping or have only <strong>one local player</strong>.</p><h3 id=21-scene-wiring>2.1 Scene wiring</h3><ol><li><strong>Add <code>ServiceCompositionRoot</code></strong> to your main scene.<ul><li>This node builds the <strong>ServiceRegistry</strong> and registers:<ul><li><code>IPlacementService</code>, <code>IManipulationService</code>, <code>IGridTargetingService</code>, etc.</li><li><code>IPlacementCommands</code>, <code>IManipulationCommands</code> (high-level facades).</li></ul></li></ul></li><li><strong>Add the session systems:</strong><ul><li>One <code>BuildingSystem</code> (or placement system node) for the scene.</li><li>One <code>ManipulationSystemNode</code> for the scene.</li></ul></li><li><strong>Add the per-user targeting node:</strong><ul><li>For a single user, add one <code>TargetingShapeCast2D</code> (or equivalent targeting script)
aligned with that user’s camera or cursor.</li></ul></li><li><strong>Add per-user HUD (optional but recommended):</strong><ul><li><code>TargetInformer</code> to show what is targeted.</li><li><code>ActionLog</code> to show recent building/manipulation actions.</li></ul></li></ol><h3 id=22-game-owned-userid-for-the-local-player>2.2 Game-owned <code>UserId</code> for the local player</h3><p>In your <strong>game code</strong> (not the plugin), create a <code>UserId</code> for the local player.</p><p>Conceptually:</p><ul><li>You decide what a “user” means (player slot, account, peer, etc.).</li><li>You create a <code>UserId</code> value that represents that user for GridBuilding.</li><li>You keep that <code>UserId</code> alongside your player/session data.</li></ul><blockquote><p>The exact construction of <code>UserId</code> is left to your game code. Treat <code>UserId</code> as a
strongly-typed key that your game owns and the plugin just consumes.</p></blockquote><h3 id=23-controller-converting-input--targeting-into-commands>2.3 Controller: converting input + targeting into commands</h3><p>Create a small controller script (per user, or just one for the single-user case) that:</p><ol><li>Resolves command facades from the <code>ServiceRegistry</code>:<ul><li><code>var placementCommands = ServiceCompositionRoot.GetGlobalService&lt;IPlacementCommands>();</code></li><li><code>var manipulationCommands = ServiceCompositionRoot.GetGlobalService&lt;IManipulationCommands>();</code></li></ul></li><li>Knows the <code>UserId</code> for this controller.</li><li>On input events and targeting updates:<ul><li>Reads the current grid position from the user’s <code>TargetingShapeCast2D</code>.</li><li>Calls the command surfaces with <code>(userId, ...)</code>.</li></ul></li></ol><p>Examples of the flows you’ll implement in that script:</p><ul><li><strong>Place:</strong><ul><li>Input: build button pressed while targeting a valid tile.</li><li>Controller: <code>placementCommands.TryPlace(userId, selectedPlaceable, worldPosition);</code></li></ul></li><li><strong>Demolish:</strong><ul><li>Input: demolish button pressed on a tile.</li><li>Controller: <code>placementCommands.TryDemolish(userId, worldPosition);</code></li></ul></li><li><strong>Manipulate (move/rotate/flip):</strong><ul><li>Input: manipulation key pressed with an active selection.</li><li>Controller calls the appropriate <code>IManipulationCommands</code> method for this <code>userId</code>.</li></ul></li></ul><h3 id=24-hud-binding-targetinformer-and-actionlog-to-the-user>2.4 HUD: binding TargetInformer and ActionLog to the user</h3><p>If you use the v6 HUD components:</p><ul><li><code>TargetInformer</code> and <code>ActionLog</code> both expose <code>InitializeForUser(UserId userId, ...)</code> helpers.</li><li>During your scene/bootstrap code, after resolving the required Core state/services, call:<ul><li><code>targetInformer.InitializeForUser(userId, buildingState, manipulationState, targetingState, modeState, settings, modeService);</code></li><li><code>actionLog.InitializeForUser(userId, buildingState, manipulationState, modeState, actions, actionLogSettings, debugSettings, logger);</code></li></ul></li></ul><p>This ensures the HUD is clearly bound to “the user this controller represents”, matching
how commands are issued.</p><hr><h2 id=3-multi-user--multiplayer-sketch>3. Multi-User / Multiplayer Sketch</h2><p>As your game grows, you will typically have:</p><ul><li>One <strong>session-level</strong> placement system and one <code>ManipulationSystemNode</code> per session.</li><li>One <strong>targeting node per user</strong> (e.g. one <code>TargetingShapeCast2D</code> per camera/player).</li><li>One <strong>controller + HUD per user</strong>, each with its own <code>UserId</code>.</li></ul><h3 id=31-game-owned-session-and-owner-model>3.1 Game-owned session and owner model</h3><p>On the game side, introduce:</p><ul><li>A per-user/session object (e.g. <code>PlayerSession</code> / <code>GameUserSession</code>) storing:<ul><li>Engine/network identifiers (controller index, peer ID, account ID, etc.).</li><li>The corresponding GridBuilding <code>UserId</code>.</li></ul></li><li>A small manager (e.g. <code>PlayerSessionManager</code>) that:<ul><li>Creates <code>UserId</code>s when players join.</li><li>Maps from engine/network identifiers → <code>UserId</code>.</li></ul></li></ul><p>When input arrives for a given player/controller, your controller looks up the proper
<code>UserId</code> from this manager and calls the shared command surfaces with that id.</p><h3 id=32-per-user-targeting-and-controllers>3.2 Per-user targeting and controllers</h3><p>For each user:</p><ul><li>Attach a <code>TargetingShapeCast2D</code> (or equivalent targeting script) to the camera or view
that represents that user.</li><li>Implement a controller script that:<ul><li>Reads input from that user (controller, keyboard, network messages, etc.).</li><li>Reads the current grid position / target from that user’s targeting node.</li><li>Calls <code>IPlacementCommands</code> / <code>IManipulationCommands</code> with that user’s <code>UserId</code>.</li><li>Updates that user’s HUD via the same <code>UserId</code>.</li></ul></li></ul><p>The session-level systems (<code>BuildingSystem</code>, <code>ManipulationSystemNode</code>) remain shared:</p><ul><li>They use the <strong>session-scoped</strong> services and state (world rules, grid, placement data).</li><li>They receive <code>UserId</code> through the command facades and consult <strong>user/owner scopes</strong> as the
architecture evolves.</li></ul><h3 id=33-where-legacy-containers-fit>3.3 Where legacy containers fit</h3><p>If you are migrating from older scenes/tests that rely on <code>CompositionContainer</code> or other
scope-style nodes:</p><ul><li>You can still use those as <strong>bridges</strong> to spin up services and state for tests or legacy
content.</li><li>New code should <strong>not</strong> use them as the primary owner of user identity; instead, they
forward to the same <code>ServiceRegistry</code> that <code>ServiceCompositionRoot</code> exposes.</li><li>Your game’s session/owner model remains the canonical source of <code>UserId</code>s.</li></ul><hr><h2 id=4-next-steps>4. Next Steps</h2><ul><li>Read the <a href=./dependency-resolution.md>Dependency Resolution</a> guide to see how
<code>ServiceCompositionRoot</code>, <code>ServiceRegistry</code>, and <code>CompositionContainer</code> relate.</li><li>Read <a href=./multi-owner-orchestration-priorities.md>Multi-Owner Orchestration Priorities</a>
for the longer-term session/owner design.</li><li>Start with the <strong>Single-User Quick Start</strong> above and evolve toward the
<strong>Multi-User / Multiplayer Sketch</strong> as your game design demands.</li></ul></div></main><aside class=gb-toc><div class=gb-toc-title>On this page</div><nav id=TableOfContents><ul><li><a href=#1-architecture-in-one-minute>1. Architecture in One Minute</a></li><li><a href=#2-single-user-quick-start>2. Single-User Quick Start</a><ul><li><a href=#21-scene-wiring>2.1 Scene wiring</a></li><li><a href=#22-game-owned-userid-for-the-local-player>2.2 Game-owned <code>UserId</code> for the local player</a></li><li><a href=#23-controller-converting-input--targeting-into-commands>2.3 Controller: converting input + targeting into commands</a></li><li><a href=#24-hud-binding-targetinformer-and-actionlog-to-the-user>2.4 HUD: binding TargetInformer and ActionLog to the user</a></li></ul></li><li><a href=#3-multi-user--multiplayer-sketch>3. Multi-User / Multiplayer Sketch</a><ul><li><a href=#31-game-owned-session-and-owner-model>3.1 Game-owned session and owner model</a></li><li><a href=#32-per-user-targeting-and-controllers>3.2 Per-user targeting and controllers</a></li><li><a href=#33-where-legacy-containers-fit>3.3 Where legacy containers fit</a></li></ul></li><li><a href=#4-next-steps>4. Next Steps</a></li></ul></nav></aside><footer class=gb-footer><p>&copy; 2025 Chris Tutorials. All rights reserved.</p><p>Built with <a href=https://gohugo.io/ target=_blank>Hugo</a> and
<a href=https://godotengine.org/ target=_blank>Godot</a>.</p></footer></div></body></html>